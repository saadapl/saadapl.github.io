{
  "version": 3,
  "sources": ["../../jotai/esm/vanilla.mjs", "../../jotai/esm/react.mjs"],
  "sourcesContent": ["let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst isPendingPromise = (value) => {\n  var _a;\n  return isPromiseLike(value) && !((_a = cancelablePromiseMap.get(value)) == null ? undefined : _a[1]);\n};\nconst cancelPromise = (promise, nextValue) => {\n  const promiseState = cancelablePromiseMap.get(promise);\n  if (promiseState) {\n    promiseState[1] = true;\n    promiseState[0].forEach((fn) => fn(nextValue));\n  } else if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\") {\n    throw new Error(\"[Bug] cancelable promise not found\");\n  }\n};\nconst patchPromiseForCancelability = (promise) => {\n  if (cancelablePromiseMap.has(promise)) {\n    return;\n  }\n  const promiseState = [/* @__PURE__ */ new Set(), false];\n  cancelablePromiseMap.set(promise, promiseState);\n  const settle = () => {\n    promiseState[1] = true;\n  };\n  promise.then(settle, settle);\n  promise.onCancel = (fn) => {\n    promiseState[0].add(fn);\n  };\n};\nconst isPromiseLike = (p) => typeof (p == null ? undefined : p.then) === \"function\";\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst addPendingPromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst addDependency = (atom, atomState, a, aState) => {\n  var _a;\n  if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && a === atom) {\n    throw new Error(\"[Bug] atom cannot depend on itself\");\n  }\n  atomState.d.set(a, aState.n);\n  if (isPendingPromise(atomState.v)) {\n    addPendingPromiseToDependency(atom, atomState.v, aState);\n  }\n  (_a = aState.m) == null ? undefined : _a.t.add(atom);\n};\nconst INTERNAL_flushStoreHook = Symbol.for(\"JOTAI.EXPERIMENTAL.FLUSHSTOREHOOK\");\nconst buildStore = (...storeArgs) => {\n  const [\n    getAtomState,\n    setAtomState,\n    atomRead,\n    atomWrite,\n    atomOnInit,\n    atomOnMount\n  ] = storeArgs;\n  const ensureAtomState = (atom) => {\n    if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && !atom) {\n      throw new Error(\"Atom is undefined or null\");\n    }\n    let atomState = getAtomState(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      setAtomState(atom, atomState);\n      atomOnInit == null ? undefined : atomOnInit(atom, store);\n    }\n    return atomState;\n  };\n  const invalidatedAtoms = /* @__PURE__ */ new WeakMap();\n  const changedAtoms = /* @__PURE__ */ new Map();\n  const unmountCallbacks = /* @__PURE__ */ new Set();\n  const mountCallbacks = /* @__PURE__ */ new Set();\n  const flushCallbacks = () => {\n    var _a;\n    const errors = [];\n    const call = (fn) => {\n      try {\n        fn();\n      } catch (e) {\n        errors.push(e);\n      }\n    };\n    do {\n      (_a = store[INTERNAL_flushStoreHook]) == null ? undefined : _a.call(store);\n      const callbacks = /* @__PURE__ */ new Set();\n      const add = callbacks.add.bind(callbacks);\n      changedAtoms.forEach((atomState) => {\n        var _a2;\n        return (_a2 = atomState.m) == null ? undefined : _a2.l.forEach(add);\n      });\n      changedAtoms.clear();\n      unmountCallbacks.forEach(add);\n      unmountCallbacks.clear();\n      mountCallbacks.forEach(add);\n      mountCallbacks.clear();\n      callbacks.forEach(call);\n      if (changedAtoms.size) {\n        recomputeInvalidatedAtoms();\n      }\n    } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n    if (errors.length) {\n      throw errors[0];\n    }\n  };\n  const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise) => {\n    const hasPrevValue = \"v\" in atomState;\n    const prevValue = atomState.v;\n    const pendingPromise = isPendingPromise(atomState.v) ? atomState.v : null;\n    if (isPromiseLike(valueOrPromise)) {\n      patchPromiseForCancelability(valueOrPromise);\n      for (const a of atomState.d.keys()) {\n        addPendingPromiseToDependency(atom, valueOrPromise, ensureAtomState(a));\n      }\n      atomState.v = valueOrPromise;\n    } else {\n      atomState.v = valueOrPromise;\n    }\n    delete atomState.e;\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n      ++atomState.n;\n      if (pendingPromise) {\n        cancelPromise(pendingPromise, valueOrPromise);\n      }\n    }\n  };\n  const readAtomState = (atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    if (isAtomStateInitialized(atomState)) {\n      if (atomState.m && invalidatedAtoms.get(atom) !== atomState.n) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(a).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const mountDependenciesIfAsync = () => {\n      if (atomState.m) {\n        mountDependencies(atom, atomState);\n        recomputeInvalidatedAtoms();\n        flushCallbacks();\n      }\n    };\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = ensureAtomState(a);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, aState2, a.init);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(a);\n      try {\n        return returnAtomValue(aState);\n      } finally {\n        addDependency(atom, atomState, a, aState);\n        if (!isSync) {\n          mountDependenciesIfAsync();\n        }\n      }\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atomRead(atom, getter, options);\n      setAtomStateValueOrPromise(atom, atomState, valueOrPromise);\n      if (isPromiseLike(valueOrPromise)) {\n        (_a = valueOrPromise.onCancel) == null ? void 0 : _a.call(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n        valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);\n      }\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const getMountedOrPendingDependents = (atomState) => {\n    var _a;\n    const dependents = /* @__PURE__ */ new Map();\n    for (const a of ((_a = atomState.m) == null ? undefined : _a.t) || []) {\n      const aState = ensureAtomState(a);\n      if (aState.m) {\n        dependents.set(a, aState);\n      }\n    }\n    for (const atomWithPendingPromise of atomState.p) {\n      dependents.set(\n        atomWithPendingPromise,\n        ensureAtomState(atomWithPendingPromise)\n      );\n    }\n    return dependents;\n  };\n  const invalidateDependents = (atomState) => {\n    const stack = [atomState];\n    while (stack.length) {\n      const aState = stack.pop();\n      for (const [d, s] of getMountedOrPendingDependents(aState)) {\n        if (!invalidatedAtoms.has(d)) {\n          invalidatedAtoms.set(d, s.n);\n          stack.push(s);\n        }\n      }\n    }\n  };\n  const recomputeInvalidatedAtoms = () => {\n    var _a;\n    const topSortedReversed = [];\n    const visiting = /* @__PURE__ */ new WeakSet();\n    const visited = /* @__PURE__ */ new WeakSet();\n    const stack = Array.from(changedAtoms);\n    while (stack.length) {\n      const [a, aState] = stack[stack.length - 1];\n      if (visited.has(a)) {\n        stack.pop();\n        continue;\n      }\n      if (visiting.has(a)) {\n        if (invalidatedAtoms.get(a) === aState.n) {\n          topSortedReversed.push([a, aState, aState.n]);\n        } else {\n          invalidatedAtoms.delete(a);\n          changedAtoms.set(a, aState);\n        }\n        visited.add(a);\n        stack.pop();\n        continue;\n      }\n      visiting.add(a);\n      for (const [d, s] of getMountedOrPendingDependents(aState)) {\n        if (!visiting.has(d)) {\n          stack.push([d, s]);\n        }\n      }\n    }\n    for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n      const [a, aState, prevEpochNumber] = topSortedReversed[i];\n      let hasChangedDeps = false;\n      for (const dep of aState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        readAtomState(a);\n        mountDependencies(a, aState);\n        if (prevEpochNumber !== aState.n) {\n          changedAtoms.set(a, aState);\n          (_a = aState.u) == null ? undefined : _a.call(aState);\n        }\n      }\n      invalidatedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      var _a;\n      const aState = ensureAtomState(a);\n      try {\n        if (isSelfAtom(atom, a)) {\n          if (!hasInitialValue(a)) {\n            throw new Error(\"atom not writable\");\n          }\n          const prevEpochNumber = aState.n;\n          const v = args2[0];\n          setAtomStateValueOrPromise(a, aState, v);\n          mountDependencies(a, aState);\n          if (prevEpochNumber !== aState.n) {\n            changedAtoms.set(a, aState);\n            (_a = aState.u) == null ? void 0 : _a.call(aState);\n            invalidateDependents(aState);\n          }\n          return void 0;\n        } else {\n          return writeAtomState(a, ...args2);\n        }\n      } finally {\n        if (!isSync) {\n          recomputeInvalidatedAtoms();\n          flushCallbacks();\n        }\n      }\n    };\n    try {\n      return atomWrite(atom, getter, setter, ...args);\n    } finally {\n      isSync = false;\n    }\n  };\n  const writeAtom = (atom, ...args) => {\n    try {\n      return writeAtomState(atom, ...args);\n    } finally {\n      recomputeInvalidatedAtoms();\n      flushCallbacks();\n    }\n  };\n  const mountDependencies = (atom, atomState) => {\n    var _a;\n    if (atomState.m && !isPendingPromise(atomState.v)) {\n      for (const [a, n] of atomState.d) {\n        if (!atomState.m.d.has(a)) {\n          const aState = ensureAtomState(a);\n          const aMounted = mountAtom(a, aState);\n          aMounted.t.add(atom);\n          atomState.m.d.add(a);\n          if (n !== aState.n) {\n            changedAtoms.set(a, aState);\n            (_a = aState.u) == null ? undefined : _a.call(aState);\n            invalidateDependents(aState);\n          }\n        }\n      }\n      for (const a of atomState.m.d || []) {\n        if (!atomState.d.has(a)) {\n          atomState.m.d.delete(a);\n          const aMounted = unmountAtom(a, ensureAtomState(a));\n          aMounted == null ? undefined : aMounted.t.delete(atom);\n        }\n      }\n    }\n  };\n  const mountAtom = (atom, atomState) => {\n    var _a;\n    if (!atomState.m) {\n      readAtomState(atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(a, ensureAtomState(a));\n        aMounted.t.add(atom);\n      }\n      atomState.m = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      (_a = atomState.h) == null ? undefined : _a.call(atomState);\n      if (isActuallyWritableAtom(atom)) {\n        const mounted = atomState.m;\n        const processOnMount = () => {\n          let isSync = true;\n          const setAtom = (...args) => {\n            try {\n              return writeAtomState(atom, ...args);\n            } finally {\n              if (!isSync) {\n                recomputeInvalidatedAtoms();\n                flushCallbacks();\n              }\n            }\n          };\n          try {\n            const onUnmount = atomOnMount(atom, setAtom);\n            if (onUnmount) {\n              mounted.u = () => {\n                isSync = true;\n                try {\n                  onUnmount();\n                } finally {\n                  isSync = false;\n                }\n              };\n            }\n          } finally {\n            isSync = false;\n          }\n        };\n        mountCallbacks.add(processOnMount);\n      }\n    }\n    return atomState.m;\n  };\n  const unmountAtom = (atom, atomState) => {\n    var _a;\n    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {\n      var _a2;\n      return (_a2 = ensureAtomState(a).m) == null ? undefined : _a2.d.has(atom);\n    })) {\n      const onUnmount = atomState.m.u;\n      if (onUnmount) {\n        unmountCallbacks.add(onUnmount);\n      }\n      delete atomState.m;\n      (_a = atomState.h) == null ? undefined : _a.call(atomState);\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(a, ensureAtomState(a));\n        aMounted == null ? undefined : aMounted.t.delete(atom);\n      }\n      return undefined;\n    }\n    return atomState.m;\n  };\n  const subscribeAtom = (atom, listener) => {\n    const atomState = ensureAtomState(atom);\n    const mounted = mountAtom(atom, atomState);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    flushCallbacks();\n    return () => {\n      listeners.delete(listener);\n      unmountAtom(atom, atomState);\n      flushCallbacks();\n    };\n  };\n  const unstable_derive = (fn) => buildStore(...fn(...storeArgs));\n  const store = {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom,\n    unstable_derive\n  };\n  return store;\n};\nconst deriveDevStoreRev4 = (store) => {\n  const debugMountedAtoms = /* @__PURE__ */ new Set();\n  let savedGetAtomState;\n  let inRestoreAtom = 0;\n  const derivedStore = store.unstable_derive((...storeArgs) => {\n    const [getAtomState, setAtomState, , atomWrite] = storeArgs;\n    savedGetAtomState = getAtomState;\n    storeArgs[1] = function devSetAtomState(atom, atomState) {\n      setAtomState(atom, atomState);\n      const originalMounted = atomState.h;\n      atomState.h = () => {\n        originalMounted == null ? undefined : originalMounted();\n        if (atomState.m) {\n          debugMountedAtoms.add(atom);\n        } else {\n          debugMountedAtoms.delete(atom);\n        }\n      };\n    };\n    storeArgs[3] = function devAtomWrite(atom, getter, setter, ...args) {\n      if (inRestoreAtom) {\n        return setter(atom, ...args);\n      }\n      return atomWrite(atom, getter, setter, ...args);\n    };\n    return storeArgs;\n  });\n  const savedStoreSet = derivedStore.set;\n  const devStore = {\n    // store dev methods (these are tentative and subject to change without notice)\n    dev4_get_internal_weak_map: () => ({\n      get: (atom) => {\n        const atomState = savedGetAtomState(atom);\n        if (!atomState || atomState.n === 0) {\n          return undefined;\n        }\n        return atomState;\n      }\n    }),\n    dev4_get_mounted_atoms: () => debugMountedAtoms,\n    dev4_restore_atoms: (values) => {\n      const restoreAtom = {\n        read: () => null,\n        write: (_get, set) => {\n          ++inRestoreAtom;\n          try {\n            for (const [atom, value] of values) {\n              if (hasInitialValue(atom)) {\n                set(atom, value);\n              }\n            }\n          } finally {\n            --inRestoreAtom;\n          }\n        }\n      };\n      savedStoreSet(restoreAtom);\n    }\n  };\n  return Object.assign(derivedStore, devStore);\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const store = buildStore(\n    (atom) => atomStateMap.get(atom),\n    (atom, atomState) => atomStateMap.set(atom, atomState).get(atom),\n    (atom, ...params) => atom.read(...params),\n    (atom, ...params) => atom.write(...params),\n    (atom, ...params) => {\n      var _a;\n      return (_a = atom.unstable_onInit) == null ? undefined : _a.call(atom, ...params);\n    },\n    (atom, ...params) => {\n      var _a;\n      return (_a = atom.onMount) == null ? undefined : _a.call(atom, ...params);\n    }\n  );\n  if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\") {\n    return deriveDevStoreRev4(store);\n  }\n  return store;\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n", "'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(\n  undefined\n);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? undefined : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef(undefined);\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? undefined : x.then) === \"function\";\nconst attachPromiseMeta = (promise) => {\n  promise.status = \"pending\";\n  promise.then(\n    (v) => {\n      promise.status = \"fulfilled\";\n      promise.value = v;\n    },\n    (e) => {\n      promise.status = \"rejected\";\n      promise.reason = e;\n    }\n  );\n};\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    attachPromiseMeta(promise);\n    throw promise;\n  }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise) => {\n  let continuablePromise = continuablePromiseMap.get(promise);\n  if (!continuablePromise) {\n    continuablePromise = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          resolve(v);\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          reject(e);\n        }\n      };\n      const registerCancelHandler = (p) => {\n        if (\"onCancel\" in p && typeof p.onCancel === \"function\") {\n          p.onCancel((nextValue) => {\n            if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && nextValue === p) {\n              throw new Error(\"[Bug] p is not updated even after cancelation\");\n            }\n            if (isPromiseLike(nextValue)) {\n              continuablePromiseMap.set(nextValue, continuablePromise);\n              curr = nextValue;\n              nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n              registerCancelHandler(nextValue);\n            } else {\n              resolve(nextValue);\n            }\n          });\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      registerCancelHandler(promise);\n    });\n    continuablePromiseMap.set(promise, continuablePromise);\n  }\n  return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    undefined,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? undefined : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        const value2 = store.get(atom);\n        if (isPromiseLike(value2)) {\n          attachPromiseMeta(createContinuablePromise(value2));\n        }\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  if (isPromiseLike(value)) {\n    const promise = createContinuablePromise(value);\n    return use(promise);\n  }\n  return value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],
  "mappings": "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",
  "names": ["atom", "isPromiseLike", "ReactExports", "atom"]
}
