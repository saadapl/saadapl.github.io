import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/jotai/esm/vanilla.mjs
var keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString() {
      return (import.meta.env ? import.meta.env.MODE : void 0) !== "production" && this.debugLabel ? key + ":" + this.debugLabel : key;
    }
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = defaultRead;
    config.write = defaultWrite;
  }
  if (write) {
    config.write = write;
  }
  return config;
}
function defaultRead(get) {
  return get(this);
}
function defaultWrite(get, set, arg) {
  return set(
    this,
    typeof arg === "function" ? arg(get(this)) : arg
  );
}
var isSelfAtom = (atom2, a) => atom2.unstable_is ? atom2.unstable_is(a) : a === atom2;
var hasInitialValue = (atom2) => "init" in atom2;
var isActuallyWritableAtom = (atom2) => !!atom2.write;
var cancelablePromiseMap = /* @__PURE__ */ new WeakMap();
var isPendingPromise = (value) => {
  var _a;
  return isPromiseLike(value) && !((_a = cancelablePromiseMap.get(value)) == null ? void 0 : _a[1]);
};
var cancelPromise = (promise, nextValue) => {
  const promiseState = cancelablePromiseMap.get(promise);
  if (promiseState) {
    promiseState[1] = true;
    promiseState[0].forEach((fn) => fn(nextValue));
  } else if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    throw new Error("[Bug] cancelable promise not found");
  }
};
var patchPromiseForCancelability = (promise) => {
  if (cancelablePromiseMap.has(promise)) {
    return;
  }
  const promiseState = [/* @__PURE__ */ new Set(), false];
  cancelablePromiseMap.set(promise, promiseState);
  const settle = () => {
    promiseState[1] = true;
  };
  promise.then(settle, settle);
  promise.onCancel = (fn) => {
    promiseState[0].add(fn);
  };
};
var isPromiseLike = (p) => typeof (p == null ? void 0 : p.then) === "function";
var isAtomStateInitialized = (atomState) => "v" in atomState || "e" in atomState;
var returnAtomValue = (atomState) => {
  if ("e" in atomState) {
    throw atomState.e;
  }
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("v" in atomState)) {
    throw new Error("[Bug] atom state is not initialized");
  }
  return atomState.v;
};
var addPendingPromiseToDependency = (atom2, promise, dependencyAtomState) => {
  if (!dependencyAtomState.p.has(atom2)) {
    dependencyAtomState.p.add(atom2);
    promise.then(
      () => {
        dependencyAtomState.p.delete(atom2);
      },
      () => {
        dependencyAtomState.p.delete(atom2);
      }
    );
  }
};
var addDependency = (atom2, atomState, a, aState) => {
  var _a;
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && a === atom2) {
    throw new Error("[Bug] atom cannot depend on itself");
  }
  atomState.d.set(a, aState.n);
  if (isPendingPromise(atomState.v)) {
    addPendingPromiseToDependency(atom2, atomState.v, aState);
  }
  (_a = aState.m) == null ? void 0 : _a.t.add(atom2);
};
var INTERNAL_flushStoreHook = Symbol.for("JOTAI.EXPERIMENTAL.FLUSHSTOREHOOK");
var buildStore = (...storeArgs) => {
  const [
    getAtomState,
    setAtomState,
    atomRead,
    atomWrite,
    atomOnInit,
    atomOnMount
  ] = storeArgs;
  const ensureAtomState = (atom2) => {
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !atom2) {
      throw new Error("Atom is undefined or null");
    }
    let atomState = getAtomState(atom2);
    if (!atomState) {
      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };
      setAtomState(atom2, atomState);
      atomOnInit == null ? void 0 : atomOnInit(atom2, store);
    }
    return atomState;
  };
  const invalidatedAtoms = /* @__PURE__ */ new WeakMap();
  const changedAtoms = /* @__PURE__ */ new Map();
  const unmountCallbacks = /* @__PURE__ */ new Set();
  const mountCallbacks = /* @__PURE__ */ new Set();
  const flushCallbacks = () => {
    var _a;
    const errors = [];
    const call = (fn) => {
      try {
        fn();
      } catch (e) {
        errors.push(e);
      }
    };
    do {
      (_a = store[INTERNAL_flushStoreHook]) == null ? void 0 : _a.call(store);
      const callbacks = /* @__PURE__ */ new Set();
      const add = callbacks.add.bind(callbacks);
      changedAtoms.forEach((atomState) => {
        var _a2;
        return (_a2 = atomState.m) == null ? void 0 : _a2.l.forEach(add);
      });
      changedAtoms.clear();
      unmountCallbacks.forEach(add);
      unmountCallbacks.clear();
      mountCallbacks.forEach(add);
      mountCallbacks.clear();
      callbacks.forEach(call);
      if (changedAtoms.size) {
        recomputeInvalidatedAtoms();
      }
    } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);
    if (errors.length) {
      throw errors[0];
    }
  };
  const setAtomStateValueOrPromise = (atom2, atomState, valueOrPromise) => {
    const hasPrevValue = "v" in atomState;
    const prevValue = atomState.v;
    const pendingPromise = isPendingPromise(atomState.v) ? atomState.v : null;
    if (isPromiseLike(valueOrPromise)) {
      patchPromiseForCancelability(valueOrPromise);
      for (const a of atomState.d.keys()) {
        addPendingPromiseToDependency(atom2, valueOrPromise, ensureAtomState(a));
      }
      atomState.v = valueOrPromise;
    } else {
      atomState.v = valueOrPromise;
    }
    delete atomState.e;
    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {
      ++atomState.n;
      if (pendingPromise) {
        cancelPromise(pendingPromise, valueOrPromise);
      }
    }
  };
  const readAtomState = (atom2) => {
    var _a;
    const atomState = ensureAtomState(atom2);
    if (isAtomStateInitialized(atomState)) {
      if (atomState.m && invalidatedAtoms.get(atom2) !== atomState.n) {
        return atomState;
      }
      if (Array.from(atomState.d).every(
        ([a, n]) => (
          // Recursively, read the atom state of the dependency, and
          // check if the atom epoch number is unchanged
          readAtomState(a).n === n
        )
      )) {
        return atomState;
      }
    }
    atomState.d.clear();
    let isSync = true;
    const mountDependenciesIfAsync = () => {
      if (atomState.m) {
        mountDependencies(atom2, atomState);
        recomputeInvalidatedAtoms();
        flushCallbacks();
      }
    };
    const getter = (a) => {
      if (isSelfAtom(atom2, a)) {
        const aState2 = ensureAtomState(a);
        if (!isAtomStateInitialized(aState2)) {
          if (hasInitialValue(a)) {
            setAtomStateValueOrPromise(a, aState2, a.init);
          } else {
            throw new Error("no atom init");
          }
        }
        return returnAtomValue(aState2);
      }
      const aState = readAtomState(a);
      try {
        return returnAtomValue(aState);
      } finally {
        addDependency(atom2, atomState, a, aState);
        if (!isSync) {
          mountDependenciesIfAsync();
        }
      }
    };
    let controller;
    let setSelf;
    const options = {
      get signal() {
        if (!controller) {
          controller = new AbortController();
        }
        return controller.signal;
      },
      get setSelf() {
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !isActuallyWritableAtom(atom2)) {
          console.warn("setSelf function cannot be used with read-only atom");
        }
        if (!setSelf && isActuallyWritableAtom(atom2)) {
          setSelf = (...args) => {
            if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && isSync) {
              console.warn("setSelf function cannot be called in sync");
            }
            if (!isSync) {
              return writeAtom(atom2, ...args);
            }
          };
        }
        return setSelf;
      }
    };
    try {
      const valueOrPromise = atomRead(atom2, getter, options);
      setAtomStateValueOrPromise(atom2, atomState, valueOrPromise);
      if (isPromiseLike(valueOrPromise)) {
        (_a = valueOrPromise.onCancel) == null ? void 0 : _a.call(valueOrPromise, () => controller == null ? void 0 : controller.abort());
        valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);
      }
      return atomState;
    } catch (error) {
      delete atomState.v;
      atomState.e = error;
      ++atomState.n;
      return atomState;
    } finally {
      isSync = false;
    }
  };
  const readAtom = (atom2) => returnAtomValue(readAtomState(atom2));
  const getMountedOrPendingDependents = (atomState) => {
    var _a;
    const dependents = /* @__PURE__ */ new Map();
    for (const a of ((_a = atomState.m) == null ? void 0 : _a.t) || []) {
      const aState = ensureAtomState(a);
      if (aState.m) {
        dependents.set(a, aState);
      }
    }
    for (const atomWithPendingPromise of atomState.p) {
      dependents.set(
        atomWithPendingPromise,
        ensureAtomState(atomWithPendingPromise)
      );
    }
    return dependents;
  };
  const invalidateDependents = (atomState) => {
    const stack = [atomState];
    while (stack.length) {
      const aState = stack.pop();
      for (const [d, s] of getMountedOrPendingDependents(aState)) {
        if (!invalidatedAtoms.has(d)) {
          invalidatedAtoms.set(d, s.n);
          stack.push(s);
        }
      }
    }
  };
  const recomputeInvalidatedAtoms = () => {
    var _a;
    const topSortedReversed = [];
    const visiting = /* @__PURE__ */ new WeakSet();
    const visited = /* @__PURE__ */ new WeakSet();
    const stack = Array.from(changedAtoms);
    while (stack.length) {
      const [a, aState] = stack[stack.length - 1];
      if (visited.has(a)) {
        stack.pop();
        continue;
      }
      if (visiting.has(a)) {
        if (invalidatedAtoms.get(a) === aState.n) {
          topSortedReversed.push([a, aState, aState.n]);
        } else {
          invalidatedAtoms.delete(a);
          changedAtoms.set(a, aState);
        }
        visited.add(a);
        stack.pop();
        continue;
      }
      visiting.add(a);
      for (const [d, s] of getMountedOrPendingDependents(aState)) {
        if (!visiting.has(d)) {
          stack.push([d, s]);
        }
      }
    }
    for (let i = topSortedReversed.length - 1; i >= 0; --i) {
      const [a, aState, prevEpochNumber] = topSortedReversed[i];
      let hasChangedDeps = false;
      for (const dep of aState.d.keys()) {
        if (dep !== a && changedAtoms.has(dep)) {
          hasChangedDeps = true;
          break;
        }
      }
      if (hasChangedDeps) {
        readAtomState(a);
        mountDependencies(a, aState);
        if (prevEpochNumber !== aState.n) {
          changedAtoms.set(a, aState);
          (_a = aState.u) == null ? void 0 : _a.call(aState);
        }
      }
      invalidatedAtoms.delete(a);
    }
  };
  const writeAtomState = (atom2, ...args) => {
    let isSync = true;
    const getter = (a) => returnAtomValue(readAtomState(a));
    const setter = (a, ...args2) => {
      var _a;
      const aState = ensureAtomState(a);
      try {
        if (isSelfAtom(atom2, a)) {
          if (!hasInitialValue(a)) {
            throw new Error("atom not writable");
          }
          const prevEpochNumber = aState.n;
          const v = args2[0];
          setAtomStateValueOrPromise(a, aState, v);
          mountDependencies(a, aState);
          if (prevEpochNumber !== aState.n) {
            changedAtoms.set(a, aState);
            (_a = aState.u) == null ? void 0 : _a.call(aState);
            invalidateDependents(aState);
          }
          return void 0;
        } else {
          return writeAtomState(a, ...args2);
        }
      } finally {
        if (!isSync) {
          recomputeInvalidatedAtoms();
          flushCallbacks();
        }
      }
    };
    try {
      return atomWrite(atom2, getter, setter, ...args);
    } finally {
      isSync = false;
    }
  };
  const writeAtom = (atom2, ...args) => {
    try {
      return writeAtomState(atom2, ...args);
    } finally {
      recomputeInvalidatedAtoms();
      flushCallbacks();
    }
  };
  const mountDependencies = (atom2, atomState) => {
    var _a;
    if (atomState.m && !isPendingPromise(atomState.v)) {
      for (const [a, n] of atomState.d) {
        if (!atomState.m.d.has(a)) {
          const aState = ensureAtomState(a);
          const aMounted = mountAtom(a, aState);
          aMounted.t.add(atom2);
          atomState.m.d.add(a);
          if (n !== aState.n) {
            changedAtoms.set(a, aState);
            (_a = aState.u) == null ? void 0 : _a.call(aState);
            invalidateDependents(aState);
          }
        }
      }
      for (const a of atomState.m.d || []) {
        if (!atomState.d.has(a)) {
          atomState.m.d.delete(a);
          const aMounted = unmountAtom(a, ensureAtomState(a));
          aMounted == null ? void 0 : aMounted.t.delete(atom2);
        }
      }
    }
  };
  const mountAtom = (atom2, atomState) => {
    var _a;
    if (!atomState.m) {
      readAtomState(atom2);
      for (const a of atomState.d.keys()) {
        const aMounted = mountAtom(a, ensureAtomState(a));
        aMounted.t.add(atom2);
      }
      atomState.m = {
        l: /* @__PURE__ */ new Set(),
        d: new Set(atomState.d.keys()),
        t: /* @__PURE__ */ new Set()
      };
      (_a = atomState.h) == null ? void 0 : _a.call(atomState);
      if (isActuallyWritableAtom(atom2)) {
        const mounted = atomState.m;
        const processOnMount = () => {
          let isSync = true;
          const setAtom = (...args) => {
            try {
              return writeAtomState(atom2, ...args);
            } finally {
              if (!isSync) {
                recomputeInvalidatedAtoms();
                flushCallbacks();
              }
            }
          };
          try {
            const onUnmount = atomOnMount(atom2, setAtom);
            if (onUnmount) {
              mounted.u = () => {
                isSync = true;
                try {
                  onUnmount();
                } finally {
                  isSync = false;
                }
              };
            }
          } finally {
            isSync = false;
          }
        };
        mountCallbacks.add(processOnMount);
      }
    }
    return atomState.m;
  };
  const unmountAtom = (atom2, atomState) => {
    var _a;
    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {
      var _a2;
      return (_a2 = ensureAtomState(a).m) == null ? void 0 : _a2.d.has(atom2);
    })) {
      const onUnmount = atomState.m.u;
      if (onUnmount) {
        unmountCallbacks.add(onUnmount);
      }
      delete atomState.m;
      (_a = atomState.h) == null ? void 0 : _a.call(atomState);
      for (const a of atomState.d.keys()) {
        const aMounted = unmountAtom(a, ensureAtomState(a));
        aMounted == null ? void 0 : aMounted.t.delete(atom2);
      }
      return void 0;
    }
    return atomState.m;
  };
  const subscribeAtom = (atom2, listener) => {
    const atomState = ensureAtomState(atom2);
    const mounted = mountAtom(atom2, atomState);
    const listeners = mounted.l;
    listeners.add(listener);
    flushCallbacks();
    return () => {
      listeners.delete(listener);
      unmountAtom(atom2, atomState);
      flushCallbacks();
    };
  };
  const unstable_derive = (fn) => buildStore(...fn(...storeArgs));
  const store = {
    get: readAtom,
    set: writeAtom,
    sub: subscribeAtom,
    unstable_derive
  };
  return store;
};
var deriveDevStoreRev4 = (store) => {
  const debugMountedAtoms = /* @__PURE__ */ new Set();
  let savedGetAtomState;
  let inRestoreAtom = 0;
  const derivedStore = store.unstable_derive((...storeArgs) => {
    const [getAtomState, setAtomState, , atomWrite] = storeArgs;
    savedGetAtomState = getAtomState;
    storeArgs[1] = function devSetAtomState(atom2, atomState) {
      setAtomState(atom2, atomState);
      const originalMounted = atomState.h;
      atomState.h = () => {
        originalMounted == null ? void 0 : originalMounted();
        if (atomState.m) {
          debugMountedAtoms.add(atom2);
        } else {
          debugMountedAtoms.delete(atom2);
        }
      };
    };
    storeArgs[3] = function devAtomWrite(atom2, getter, setter, ...args) {
      if (inRestoreAtom) {
        return setter(atom2, ...args);
      }
      return atomWrite(atom2, getter, setter, ...args);
    };
    return storeArgs;
  });
  const savedStoreSet = derivedStore.set;
  const devStore = {
    // store dev methods (these are tentative and subject to change without notice)
    dev4_get_internal_weak_map: () => ({
      get: (atom2) => {
        const atomState = savedGetAtomState(atom2);
        if (!atomState || atomState.n === 0) {
          return void 0;
        }
        return atomState;
      }
    }),
    dev4_get_mounted_atoms: () => debugMountedAtoms,
    dev4_restore_atoms: (values) => {
      const restoreAtom = {
        read: () => null,
        write: (_get, set) => {
          ++inRestoreAtom;
          try {
            for (const [atom2, value] of values) {
              if (hasInitialValue(atom2)) {
                set(atom2, value);
              }
            }
          } finally {
            --inRestoreAtom;
          }
        }
      };
      savedStoreSet(restoreAtom);
    }
  };
  return Object.assign(derivedStore, devStore);
};
var createStore = () => {
  const atomStateMap = /* @__PURE__ */ new WeakMap();
  const store = buildStore(
    (atom2) => atomStateMap.get(atom2),
    (atom2, atomState) => atomStateMap.set(atom2, atomState).get(atom2),
    (atom2, ...params) => atom2.read(...params),
    (atom2, ...params) => atom2.write(...params),
    (atom2, ...params) => {
      var _a;
      return (_a = atom2.unstable_onInit) == null ? void 0 : _a.call(atom2, ...params);
    },
    (atom2, ...params) => {
      var _a;
      return (_a = atom2.onMount) == null ? void 0 : _a.call(atom2, ...params);
    }
  );
  if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
    return deriveDevStoreRev4(store);
  }
  return store;
};
var defaultStore;
var getDefaultStore = () => {
  if (!defaultStore) {
    defaultStore = createStore();
    if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);
      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {
        console.warn(
          "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
        );
      }
    }
  }
  return defaultStore;
};

// node_modules/jotai/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var StoreContext = (0, import_react.createContext)(
  void 0
);
var useStore = (options) => {
  const store = (0, import_react.useContext)(StoreContext);
  return (options == null ? void 0 : options.store) || store || getDefaultStore();
};
var Provider = ({
  children,
  store
}) => {
  const storeRef = (0, import_react.useRef)(void 0);
  if (!store && !storeRef.current) {
    storeRef.current = createStore();
  }
  return (0, import_react.createElement)(
    StoreContext.Provider,
    {
      value: store || storeRef.current
    },
    children
  );
};
var isPromiseLike2 = (x) => typeof (x == null ? void 0 : x.then) === "function";
var attachPromiseMeta = (promise) => {
  promise.status = "pending";
  promise.then(
    (v) => {
      promise.status = "fulfilled";
      promise.value = v;
    },
    (e) => {
      promise.status = "rejected";
      promise.reason = e;
    }
  );
};
var use = import_react.default.use || ((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    attachPromiseMeta(promise);
    throw promise;
  }
});
var continuablePromiseMap = /* @__PURE__ */ new WeakMap();
var createContinuablePromise = (promise) => {
  let continuablePromise = continuablePromiseMap.get(promise);
  if (!continuablePromise) {
    continuablePromise = new Promise((resolve, reject) => {
      let curr = promise;
      const onFulfilled = (me) => (v) => {
        if (curr === me) {
          resolve(v);
        }
      };
      const onRejected = (me) => (e) => {
        if (curr === me) {
          reject(e);
        }
      };
      const registerCancelHandler = (p) => {
        if ("onCancel" in p && typeof p.onCancel === "function") {
          p.onCancel((nextValue) => {
            if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && nextValue === p) {
              throw new Error("[Bug] p is not updated even after cancelation");
            }
            if (isPromiseLike2(nextValue)) {
              continuablePromiseMap.set(nextValue, continuablePromise);
              curr = nextValue;
              nextValue.then(onFulfilled(nextValue), onRejected(nextValue));
              registerCancelHandler(nextValue);
            } else {
              resolve(nextValue);
            }
          });
        }
      };
      promise.then(onFulfilled(promise), onRejected(promise));
      registerCancelHandler(promise);
    });
    continuablePromiseMap.set(promise, continuablePromise);
  }
  return continuablePromise;
};
function useAtomValue(atom2, options) {
  const store = useStore(options);
  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0, import_react.useReducer)(
    (prev) => {
      const nextValue = store.get(atom2);
      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {
        return prev;
      }
      return [nextValue, store, atom2];
    },
    void 0,
    () => [store.get(atom2), store, atom2]
  );
  let value = valueFromReducer;
  if (storeFromReducer !== store || atomFromReducer !== atom2) {
    rerender();
    value = store.get(atom2);
  }
  const delay = options == null ? void 0 : options.delay;
  (0, import_react.useEffect)(() => {
    const unsub = store.sub(atom2, () => {
      if (typeof delay === "number") {
        const value2 = store.get(atom2);
        if (isPromiseLike2(value2)) {
          attachPromiseMeta(createContinuablePromise(value2));
        }
        setTimeout(rerender, delay);
        return;
      }
      rerender();
    });
    rerender();
    return unsub;
  }, [store, atom2, delay]);
  (0, import_react.useDebugValue)(value);
  if (isPromiseLike2(value)) {
    const promise = createContinuablePromise(value);
    return use(promise);
  }
  return value;
}
function useSetAtom(atom2, options) {
  const store = useStore(options);
  const setAtom = (0, import_react.useCallback)(
    (...args) => {
      if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production" && !("write" in atom2)) {
        throw new Error("not writable atom");
      }
      return store.set(atom2, ...args);
    },
    [store, atom2]
  );
  return setAtom;
}
function useAtom(atom2, options) {
  return [
    useAtomValue(atom2, options),
    // We do wrong type assertion here, which results in throwing an error.
    useSetAtom(atom2, options)
  ];
}
export {
  Provider,
  atom,
  createStore,
  getDefaultStore,
  useAtom,
  useAtomValue,
  useSetAtom,
  useStore
};
//# sourceMappingURL=jotai.js.map
